<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="referrer" content="no-referrer"><meta http-equiv="X-UA-Compatible" content="ie=edge"><title>es6/generator | Scott Wu</title><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"><script src="/js/third-party/jquery.min.js">           </script><script src="/js/third-party/velocity.min.js">           </script><script src="/js/third-party/velocity.ui.min.js">           </script><link rel="icon" href="/img/scott.ico"><meta name="keywords" content="前端博客,Scott_Stark,blog,前端,软件开发,个人博客,个人网站,ECMAScript ECMAScript6 es6 es6-generator"><meta name="generator" content="Hexo 4.2.0"></head><body><nav id="nav-bar"><nav class="clear-fix" id="nav-container"><div class="pull-left" id="page-home"><a href="/">Scott Wu</a></div><i class="fa fa-bars pull-right" id="toggle-nav" aria-hidden="true"></i><ul class="pull-right" id="navs"><li><a class="nav" href="/">Home</a></li><li><a class="nav" href="/about">About</a></li><li><a class="nav" href="/tags">Tags</a></li></ul></nav></nav><header id="header-info"><div id="header-container"><div id="site-info"><div id="terminal-pl"><div id="top-bar"><ul id="control"><li class="btn"></li><li class="btn"></li><li class="btn"></li></ul><div id="file-path"><i class="fa fa-folder folder-ic" aria-hidden="true"></i> Scott Wu @  ES6/GENERATOR</div></div><div id="code-pl">Last updated: 2022-06-14<br>Scott Wu:~ Desktop <span class="code-pl-input">$ Please don't reprint without permission</span><br><br>> Post.all <br></div></div></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><a class="article-title">es6/generator</a><time class="article-date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-14</time><h1 id="es6-generator"><a href="#es6-generator" class="headerlink" title="es6-generator"></a><strong>es6-generator</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>  &emsp;&emsp;在各路文档中，了解到 <code>Generator</code> 是一个生成器，目的是为了生成一个 <code>Iterator</code> – <code>&quot;迭代器&quot;</code>，用以进行流程控制，让代码在你需要停止的地方提下来，并能够在下次流程进行的时候在上次停止的地方开始。</p>
<p>  &emsp;&emsp;其中有几个重要的名次及其概念列举如下：</p>
<ul>
<li><p><code>Generator</code> 其译为生成器，目的是为了通过其创建一个迭代器，声明方法如下👇；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>*</code> 的位置并没有强制限制，只要保证在 <code>function</code> 与生成器名称之间就可以了。</p>
</li>
<li><p><code>next()</code> 为获取迭代器执行结果的方法，主要用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gf = generatorFun();</span><br><span class="line">gf.next();  <span class="comment">// &#123; value:1, done: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>  需要注意的是，直接调用 <code>generatorFun</code>，并不能像常规函数那样直接获取函数执行结果，而是获得了一个迭代器 <code>Iterator</code>，在找到的一些文章中，大多愿意称其为指向函数内部状态的 <code>指针对象</code>，当调用迭代器对象内的 <code>next</code> 方法时，其指针便会从函数头部或上一次停下来的地方继续执行；</p>
</li>
<li><p><code>yield</code> 其译为产出，产出的是其后面的表达式的运行结果，然后在 <code>yield</code> 处暂停执行，直到下次调用 <code>next</code> 方法触发才会在停止处继续执行，且当 <code>yield</code> 用在表达式中时，需要放在圆括号里，如下，：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="string">'world'</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="string">'world'</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h2><p>  &emsp;&emsp;从上述描述中基本可以了解到 <code>Generator</code> 的基本用法如下👇图所示。</p>
<p>  <img src="/images/generator.png" alt="Generator 基本用法流程图"></p>
<p>  &emsp;&emsp;其中有这么几个需要注意的点<sup><a href="#flowchat-diff">[1]</a></sup>：</p>
<ul>
<li><p>如上图中的代码，即使只有一个 <code>yield</code>，当第一次调用 <code>gf.next()</code> 也并没有直接到 <code>done</code> 的状态，这其实比较好理解，因为第一次的 <code>next</code> 并没有使代码运行到函数尾部，而是停留在了 <code>yield</code> 上，尽管 <code>yield</code> 之后再无可执行代码；</p>
</li>
<li><p>生成器函数执行流程区别于普通函数，举个🌰：<br><img src="/images/flowchat-diff.png" alt="生成器函数与普通函数比较"><br>从上图可以看到，普通函数与生成器函数的执行顺序主要区别在于 <code>yield</code> 表达式使得每一次调用 <code>next</code> 最终都会将函数暂停在 <code>yield</code> 表达式或者函数尾部，直到下次调用 <code>next</code> 将从上一个 <code>yield</code> 运行到下一个 <code>yield</code> 或者函数尾部。</p>
</li>
<li><p>从上图的生成函数代码中会发现一个问题，就是最后的输出结果是 <code>NaN</code>，这其实是因为 <code>yield</code> 只负责<code>“产出”</code>导致的，也就是 <code>yield</code> 表达式并不能将它右侧的表达式运行结果返回到左侧，而如果需要上一步的结果，则可以借助 <code>next</code> 来进行传参，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. a"</span>, a) <span class="comment">// 2</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gf = generatorFun();</span><br><span class="line"><span class="keyword">const</span> a = gf.next();</span><br><span class="line">gf.next(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h2><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a><strong><code>for of</code></strong></h3><p>  &emsp;&emsp;<code>for of</code> 循环可以自动遍历 <code>Generator</code> 函数时生成的 <code>Iterator</code> 对象，且此时不再需要调用 <code>next</code> 方法。如下：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">for0f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' javascript'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> for0f())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. ~ v"</span>, v)</span><br><span class="line">&#125; <span class="comment">// 'hello', ' ', 'world'</span></span><br></pre></td></tr></table></figure><br>  &emsp;&emsp;通过观察输出结果，我们发现一个问题，就是最后的 <code>javascript</code> 并没有输出出来，这是因为 <code>for of</code> 循环在 <code>done === true</code> 时便中止掉了，并且不会返回当前结果，所以最后的 <code>return</code> 结果并没有获取到。</p>
<p>  &emsp;&emsp;除了 <code>for...of</code> 循环以外，扩展运算符（<code>...</code>）、解构赋值和 <code>Array.from</code><sup><a href="#array-from">[2]</a></sup> 方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code>Generator</code> 函数返回的 <code>Iterator</code> 对象，作为参数。<sup><a href="#es6-generator-jianshu1">[3]</a></sup></p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">for0f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'javascript'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> for0f()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'hello', ' ', 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...for0f()] <span class="comment">// ['hello', ' ', 'world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z] = for0f();</span><br><span class="line">x <span class="comment">// 'hello'</span></span><br><span class="line">y <span class="comment">// ' '</span></span><br><span class="line">z <span class="comment">// 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(for0f()) <span class="comment">// ['hello', ' ', 'world]</span></span><br></pre></td></tr></table></figure>

<h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a><strong><code>Generator.prototype.throw()</code></strong></h3><p>  &emsp;&emsp;一个在生成器函数外部向函数体内部抛出错误的方法。</p>
<h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a><strong><code>Generator.prototype.return()</code></strong></h3><p>  &emsp;&emsp;一个在生成器函数外部向函数体内部 <code>return</code>，并终结遍历。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a><strong><code>yield*</code></strong></h3><p>  &emsp;&emsp;<code>yield*</code> 表达式用于委托给另一个 <code>generator</code> 或 <code>可迭代对象</code><sup><a href="#iterable-object">[4]</a></sup>。<sup><a href="#es6-yield*">[5]</a></sup></p>
<p>  &emsp;&emsp;<code>yield*</code> 有区别于 <code>yield</code>。<code>yield</code> 可以将其理解为暂停标识符，即在 <code>yield</code> 处开始或停止。而 <code>yield*</code> 则可以理解为展开一个可迭代对象进行迭代。举个🌰：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* gf2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>  &emsp;&emsp;上述代码其实可以看作等价于下面的代码<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  yield_return <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  &emsp;&emsp;只不过有一条需要注意的是 <code>yield_return</code> 是我为了方便理解自己定义的一个标识，实际上是没有这个东西的。之所以这么定义是因为 <code>yield*</code> 所委托的迭代对象 <code>return</code> 的 <code>value</code> 将作为返回值返回到 <code>yield*</code> 表达式上，再举个🌰：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v = <span class="keyword">yield</span>* gf2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. ~ function*gf1 ~ v"</span>, v)  <span class="comment">// 🐛. ~ function*gf1 ~ v,3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>参考资料:</p>
<p>[1]. <a href="https://blog.csdn.net/weixin_39798049/article/details/87111633" target="_blank" rel="noopener">es 异步流程(二)之generator篇</a> <span id="flowchat-diff"></span></p>
<p>[2]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from</a> <span id="array-from"></span></p>
<p>[3]. <a href="https://www.jianshu.com/p/56000dcf7cfe" target="_blank" rel="noopener">ES6中的Generator函数</a> <span id="es6-generator-jianshu1"></span></p>
<p>[4]. <a href="https://juejin.cn/post/6873457657018728456" target="_blank" rel="noopener">JS 可迭代对象</a> <span id="iterable-object"></span></p>
<p>[5]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*" target="_blank" rel="noopener">yield*</a> <span id="es6-yield*"></span></p>
<p>[6]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p>
</blockquote>
<hr>
<h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6></article><nav id="pagination"><div class="pagination clear-fix"><div class="page-next pull-right"><a href="/2022/06/07/http-cookies/"><span>http/cookies</span><i class="fa fa-chevron-right"></i></a></div></div></nav></div></div><footer><div id="footer-inner"><div class="social-icons"></div><p class="design-info">power by <a href="">Hexo</a> | theme <a href="">Teminal</a> </p><p class="copyright">Copyright © Scott Wu Blog 2022</p></div></footer><script src="/js/nav.js"></script><script src="/js/scroll.js"></script><script src="/js/index.js"></script></body></html>