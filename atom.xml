<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott Wu</title>
  
  
  <link href="https://blog.scottwu.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.scottwu.cn/"/>
  <updated>2022-11-28T14:14:18.166Z</updated>
  <id>https://blog.scottwu.cn/</id>
  
  <author>
    <name>Scott Wu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://blog.scottwu.cn/2022/11/28/0730day07/"/>
    <id>https://blog.scottwu.cn/2022/11/28/0730day07/</id>
    <published>2022-11-28T14:10:17.000Z</published>
    <updated>2022-11-28T14:14:18.166Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h6 id=&quot;以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。&quot;&gt;&lt;a href=&quot;#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。&quot; class=&quot;headerlink&quot; title=&quot;以上描述及</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="https://blog.scottwu.cn/2022/10/09/0730day06/"/>
    <id>https://blog.scottwu.cn/2022/10/09/0730day06/</id>
    <published>2022-10-09T14:33:49.000Z</published>
    <updated>2022-11-22T14:11:53.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能指标有哪些"><a href="#性能指标有哪些" class="headerlink" title="性能指标有哪些"></a>性能指标有哪些</h2><h3 id="FP-First-Paint"><a href="#FP-First-Paint" class="headerlink" title="FP (First Paint)"></a><code>FP (First Paint)</code></h3><p>指到页面第一个像素点绘制时所花费的时间，通常反映的是白屏时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算方法</span></span><br><span class="line">performance</span><br><span class="line">  .getEntriesByType(<span class="string">'paint'</span>)</span><br><span class="line">  .find(<span class="function"><span class="params">_perf</span> =&gt;</span> <span class="string">'first-paint'</span> === _perf.name);</span><br></pre></td></tr></table></figure><h3 id="FCP-First-Contentful-Paint"><a href="#FCP-First-Contentful-Paint" class="headerlink" title="FCP (First Contentful Paint)"></a><code>FCP (First Contentful Paint)</code></h3><p>为首次有内容渲染的时间点，在性能统计指标中，从用户开始访问 Web 页面的时间点到 FCP 的时间点这段时间可以被视为无内容时间，一般 <code>FCP</code> &gt;= <code>FP</code>。<br>计算方法同上，只不过 <code>name</code> 为 <code>first-contentful-paint</code>。</p><h3 id="FMP-First-Meaningful-Paint"><a href="#FMP-First-Meaningful-Paint" class="headerlink" title="FMP (First Meaningful Paint)"></a><code>FMP (First Meaningful Paint)</code></h3><p>为首次有效绘制，具体是指从页面加载开始，到大部分或者主要内容已经在首屏上渲染的时间点。</p><h3 id="LCP-Largest-Contentful-Paint"><a href="#LCP-Largest-Contentful-Paint" class="headerlink" title="LCP (Largest Contentful Paint)"></a><code>LCP (Largest Contentful Paint)</code></h3><p>指的是在视窗内，最大的内容元素被渲染的时间。这个指标在 <code>Lighthouse 6.0</code> 中也正式加入，并且在最终性能评分中，有高达25%的权重。</p><h3 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a><code>首屏时间</code></h3><p>首屏时间是指用户打开网站开始，到浏览器首屏内容渲染完成的时间。</p><h3 id="TTI-Time-To-Interactive"><a href="#TTI-Time-To-Interactive" class="headerlink" title="TTI (Time To Interactive)"></a><code>TTI (Time To Interactive)</code></h3><p>TTI 指标测量页面从开始加载到主要子资源完成渲染，并能够快速、可靠地响应用户输入所需的时间。</p><h3 id="TTFB-Time-To-First-Byte"><a href="#TTFB-Time-To-First-Byte" class="headerlink" title="TTFB (Time To First Byte) "></a><code>TTFB (Time To First Byte)</code> <span id="time-to-first-byte"></span></h3><p>TTFB 是一个衡量对资源的请求和响应的第一个字节开始和到达之间时间的指标。</p><h3 id="FID-First-Input-Delay"><a href="#FID-First-Input-Delay" class="headerlink" title="FID (First Input Delay)"></a><code>FID (First Input Delay)</code></h3><p>FID 测量从用户第一次与页面交互（例如当他们单击链接、点按按钮或使用由 JavaScript 驱动的自定义控件）直到浏览器对交互作出响应，并实际能够开始处理事件处理程序所经过的时间。</p><h3 id="CLS-Cumulative-Layout-Shift"><a href="#CLS-Cumulative-Layout-Shift" class="headerlink" title="CLS (Cumulative Layout Shift)"></a><code>CLS (Cumulative Layout Shift)</code></h3><p>CLS 测量整个页面生命周期内发生的所有意外布局偏移中最大一连串的布局偏移分数。</p><h2 id="PerfomanceObserver"><a href="#PerfomanceObserver" class="headerlink" title="PerfomanceObserver"></a><code>PerfomanceObserver</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerfomanceObserver(<span class="function">(<span class="params">list, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  observer.disconnect();</span><br><span class="line">&#125;)</span><br><span class="line">observer.observe(&#123;</span><br><span class="line">  entryTypes: [</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@types </span></span></span><br><span class="line"><span class="comment">     * element</span></span><br><span class="line"><span class="comment">     * event</span></span><br><span class="line"><span class="comment">     * first-input</span></span><br><span class="line"><span class="comment">     * largest-contentful-paint</span></span><br><span class="line"><span class="comment">     * layout-shift</span></span><br><span class="line"><span class="comment">     * longtask</span></span><br><span class="line"><span class="comment">     * mark</span></span><br><span class="line"><span class="comment">     * measure</span></span><br><span class="line"><span class="comment">     * navigation</span></span><br><span class="line"><span class="comment">     * paint</span></span><br><span class="line"><span class="comment">     * resource</span></span><br><span class="line"><span class="comment">     * /</span></span><br><span class="line"><span class="comment">  ]</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="各项时间获取"><a href="#各项时间获取" class="headerlink" title="各项时间获取"></a>各项时间获取</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  connectStart,</span><br><span class="line">  navigationStart,</span><br><span class="line">  loadEventEnd,</span><br><span class="line">  domLoading,</span><br><span class="line">  secureConnectionStart,</span><br><span class="line">  fetchStart,</span><br><span class="line">  domContentLoadedEventStart,</span><br><span class="line">  responseStart,</span><br><span class="line">  responseEnd,</span><br><span class="line">  domInteractive,</span><br><span class="line">  domainLookupEnd,</span><br><span class="line">  redirectStart,</span><br><span class="line">  requestStart,</span><br><span class="line">  unloadEventEnd,</span><br><span class="line">  unloadEventStart,</span><br><span class="line">  domComplete,</span><br><span class="line">  domainLookupStart,</span><br><span class="line">  loadEventStart,</span><br><span class="line">  domContentLoadedEventEnd,</span><br><span class="line">  redirectEnd,</span><br><span class="line">  connectEnd</span><br><span class="line">&#125; = performance.timing;</span><br></pre></td></tr></table></figure><blockquote><p>connectTime TCP 链接耗时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connectTime = connectEnd - connectStart;</span><br></pre></td></tr></table></figure><p><a href="#time-to-first-byte">TTFB</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ttfb = responseStart - requestStart;</span><br></pre></td></tr></table></figure><p>responseTime response响应耗时</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> responseTime = responseEnd - responseStart</span><br></pre></td></tr></table></figure></blockquote><h2 id><a href="#" class="headerlink" title></a><img src="https://web-dev.imgix.net/image/jL3OLOhcWUQDnR4XjewLBx4e3PC3/ccT8ltSPrTri3tz7AA3h.png?auto=format&w=845" alt></h2><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;性能指标有哪些&quot;&gt;&lt;a href=&quot;#性能指标有哪些&quot; class=&quot;headerlink&quot; title=&quot;性能指标有哪些&quot;&gt;&lt;/a&gt;性能指标有哪些&lt;/h2&gt;&lt;h3 id=&quot;FP-First-Paint&quot;&gt;&lt;a href=&quot;#FP-First-Paint&quot; cla</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>浏览器API</title>
    <link href="https://blog.scottwu.cn/2022/09/21/0730day05/"/>
    <id>https://blog.scottwu.cn/2022/09/21/0730day05/</id>
    <published>2022-09-21T13:56:14.000Z</published>
    <updated>2022-09-27T13:55:00.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h2><h3 id="iife-模块化传参为何要加一项-undefined"><a href="#iife-模块化传参为何要加一项-undefined" class="headerlink" title="iife 模块化传参为何要加一项 undefined"></a><code>iife</code> 模块化传参为何要加一项 <code>undefined</code></h3><p>在各 <code>JS</code> 版本中，值 <code>undefined</code> 均非保留字，也就是说 <code>undefined</code> 是可以被当作变量定义的，那么也就有可能导致获取 <code>undefined</code> 的结果并非真正的 <code>undefined</code>，而是被再次声明后的 <code>undefined</code>，座椅需要在 <code>iife</code> 参数中声明 <code>undefined</code>。</p><h3 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI"></a><code>encodeURI</code></h3><p>编码除URL元字符与语义字符之外的字符</p><blockquote><ul><li>URL 元字符（保留字符）：分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li><li>语义字符（非保留字符）：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（’），圆括号（()）<sup><a href="#URL编码与解码使用详解">[1]</a></sup></li></ul></blockquote><h3 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent"></a><code>encodeURIComponent</code></h3><p>编码除语义字符（非保留字符）外的字符</p><h3 id="devicePixelRatio"><a href="#devicePixelRatio" class="headerlink" title="devicePixelRatio"></a><code>devicePixelRatio</code></h3><p>物理像素与 <code>CSS</code> 像素比</p><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://blog.csdn.net/m0_46309087/article/details/119839043" target="_blank" rel="noopener">URL编码与解码使用详解</a> <span id="URL 编码与解码使用详解"></span></p><p>[2]. <a href="https://www.jb51.net/article/256204.htm" target="_blank" rel="noopener">JS前端宏任务微任务及Event Loop使用详解</a> <span id="taks-&-eventloop"></span></p><p>[*]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Content&quot;&gt;&lt;a href=&quot;#Content&quot; class=&quot;headerlink&quot; title=&quot;Content&quot;&gt;&lt;/a&gt;&lt;code&gt;Content&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;iife-模块化传参为何要加一项-undefined&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>JS模块化</title>
    <link href="https://blog.scottwu.cn/2022/09/13/0730day04/"/>
    <id>https://blog.scottwu.cn/2022/09/13/0730day04/</id>
    <published>2022-09-13T14:38:16.000Z</published>
    <updated>2022-09-13T14:53:05.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="script-标签-async-和-defer-属性"><a href="#script-标签-async-和-defer-属性" class="headerlink" title="script 标签 async 和 defer 属性"></a><code>script</code> 标签 <code>async</code> 和 <code>defer</code> 属性</h2><p>  <code>defer</code> 与 <code>async</code> 均是异步下载脚本，不同点在于解析执行的时机不同，<code>defer</code> 较为“温柔“，会排队等待 <code>GUI</code> 线程执行完成后再去执行 <code>js</code> 脚本；而 <code>async</code> 则是在其下载完后便直接解析执行，一毫秒都不会多等。 </p><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;script-标签-async-和-defer-属性&quot;&gt;&lt;a href=&quot;#script-标签-async-和-defer-属性&quot; class=&quot;headerlink&quot; title=&quot;script 标签 async 和 defer 属性&quot;&gt;&lt;/a&gt;&lt;code&gt;sc</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://blog.scottwu.cn/2022/09/04/0730day03/"/>
    <id>https://blog.scottwu.cn/2022/09/04/0730day03/</id>
    <published>2022-09-04T05:27:59.000Z</published>
    <updated>2022-09-04T07:53:51.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><code>概念</code></h2><ul><li>宏任务 - <code>tasks</code><blockquote><p>一个 任务 就是由执行诸如从头执行一段程序、执行一个事件回调或一个 interval/timeout 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 <strong>任务队列（task queue）</strong> 上被调度。<sup><a href="#tasks-&-microtasks-of-mdn">[1]</a></sup></p></blockquote></li><li>微任务 - <code>microtasks</code><blockquote><p>两个 <code>tasks</code> 之间执行的任务。</p></blockquote></li></ul><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide" target="_blank" rel="noopener">Tasks &amp; microtasks</a> <span id="tasks-&-microtasks-of-mdn"></span></p><p>[2]. <a href="https://www.jb51.net/article/256204.htm" target="_blank" rel="noopener">JS前端宏任务微任务及Event Loop使用详解</a> <span id="taks-&-eventloop"></span></p><p>[*]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;&lt;code&gt;概念&lt;/code&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;宏任务 - &lt;code&gt;tasks&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;一个 任务 就是由执行</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>0730day11</title>
    <link href="https://blog.scottwu.cn/2022/09/03/0730day11/"/>
    <id>https://blog.scottwu.cn/2022/09/03/0730day11/</id>
    <published>2022-09-03T12:00:56.000Z</published>
    <updated>2022-09-04T05:39:13.767Z</updated>
    
    <content type="html"><![CDATA[<hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h6 id=&quot;以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。&quot;&gt;&lt;a href=&quot;#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。&quot; class=&quot;headerlink&quot; title=&quot;以上描述及</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>OOP/protoType</title>
    <link href="https://blog.scottwu.cn/2022/08/18/0730day02/"/>
    <id>https://blog.scottwu.cn/2022/08/18/0730day02/</id>
    <published>2022-08-18T13:45:09.000Z</published>
    <updated>2022-09-04T05:38:40.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h2><h3 id="为什么要面向对象"><a href="#为什么要面向对象" class="headerlink" title="为什么要面向对象"></a>为什么要面向对象</h3><h3 id="JS对象创建方法"><a href="#JS对象创建方法" class="headerlink" title="JS对象创建方法"></a><code>JS对象创建方法</code></h3><ul><li><code>Object.create</code> —— 根据参数创建以参数为原型的对象<sup><a href="#Object-create-of-mdn">[1]</a></sup></li><li>直接声明对象: <code>var const let</code></li><li><code>new</code> 关键字</li></ul><h4 id="new-关键字"><a href="#new-关键字" class="headerlink" title="new 关键字"></a><code>new</code> 关键字</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cosnt p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. p 的构造函数时 Person</span></span><br><span class="line"><span class="comment"> *  .1 new 创建一个对象，指向构造函数的原型</span></span><br><span class="line"><span class="comment"> *    - p.__proto__ === Person.protoType</span></span><br><span class="line"><span class="comment"> *  .2 构造函数上，有个原型（是个对象），里面有个 constructor 函数，就是这个构造函数本身</span></span><br><span class="line"><span class="comment"> *    - Person.prototype.constructor === Person</span></span><br><span class="line"><span class="comment"> *  .3 p 对象的构造函数是 Person</span></span><br><span class="line"><span class="comment"> *    - p.constructor === Person</span></span><br><span class="line"><span class="comment"> * /</span></span><br></pre></td></tr></table></figure><p><code>new</code> 关键字做了什么<sup><a href="#what-the-new-keyword-does-of-mdn">[2]</a></sup></p><ul><li>创建空对象 —— <code>newInstance</code></li><li>将 <code>newInstance</code> 的 <code>__proto__</code> 属性指向其构造函数原型属性 <code>prototype</code></li><li>将创建的对象作为 <code>this</code> // mdn中这么描述到：将步骤 1 新创建的对象作为<strong>this</strong>的上下文，个人理解这部分含义是将执行的构造函数的this绑定为 <code>newInstance</code></li><li><ul><li>存在返回值且为对象，则创建结果为返回对象</li></ul></li><li><ul><li>否则为创建的对象  </li></ul></li></ul><h4 id="手写-new"><a href="#手写-new" class="headerlink" title="手写 new"></a>手写 <code>new</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fake_new</span>(<span class="params">constructor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">typeof</span> <span class="keyword">constructor</span> === 'function') &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'constructor must be a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(<span class="keyword">constructor</span>.prototype);</span><br><span class="line"></span><br><span class="line">  const res = <span class="keyword">constructor</span>.apply(obj, args);</span><br><span class="line"></span><br><span class="line">  if(res instanceof Object) &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125; <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>实现继承，其核心可以概括为以下两部分</p><ol><li>使用父类的构造函数方法和原型函数</li><li>让对象的原型链指向父类</li></ol><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()</a> <span id="Object-create-of-mdn"></span></p><p>[2]. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new#:~:text=called%20without%20arguments.-,Description,-When%20a%20function" target="_blank" rel="noopener">What the new keyword does</a> <span id="what-the-new-keyword-does-of-mdn"></span></p><p>[*]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Content&quot;&gt;&lt;a href=&quot;#Content&quot; class=&quot;headerlink&quot; title=&quot;Content&quot;&gt;&lt;/a&gt;&lt;code&gt;Content&lt;/code&gt;&lt;/h2&gt;&lt;h3 id=&quot;为什么要面向对象&quot;&gt;&lt;a href=&quot;#为什么要面向对象&quot; cl</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>this指针/闭包/作用域</title>
    <link href="https://blog.scottwu.cn/2022/08/14/0730day01/"/>
    <id>https://blog.scottwu.cn/2022/08/14/0730day01/</id>
    <published>2022-08-14T06:06:33.000Z</published>
    <updated>2022-08-18T13:44:00.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p><strong>JIT</strong><br>—— <code>Just in time</code> 运行时编译。。。</p><p><strong>非表达式函数</strong><sup><a href="#Expressions-of-mdn">[1]</a></sup><br>—— 即非直接通过 <code>function</code> 语法直接定义而成的的函数</p><p><strong>变量提升</strong> <code>let</code> <code>const</code> 可能存在，但没有纠结的意义，<code>Chrome</code> 浏览器 <code>debugger</code> 可见得变量被提升<br><img src="http://tva1.sinaimg.cn/large/006rt2YXly1h56c9cn1y2j3067083751.jpg" alt="let, const变量提升"></p><p>LHS<br>—— 赋值操作左侧 left</p><p>RHS<br>—— 赋值操作右侧 right</p><p>词法作用域<br>—— 代码里的作用域</p><p>IIFE<br>—— 立即执行函数</p></blockquote><h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a><code>Content</code></h2><p><code>this</code> 的指向，是根据上下文动态决定的。</p><ul><li>在简单调用时，<code>this</code> 默认指向 <code>window (Explorer)</code>, <code>global (NodeJS)</code>, <code>undefined (Strict Mode)</code></li><li>对象调用时，绑定在对象上</li><li>使用 <code>call</code>, <code>apply</code>, <code>bind</code> 时，绑定在指定参数上</li><li>使用 <code>new</code> 时，绑定到新创建对象上</li><li><ul><li>以上部分优先级：new &gt; call/apply/bind &gt; 对象调用</li></ul></li><li>箭头函数 <code>this</code>, 根据外围规则决定</li></ul><p><code>IIFE</code> 立即执行，代码执行到其部位时会立即执行，如下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iifeObj = &#123;</span><br><span class="line">  fn: <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'iifeObj'</span>)</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125; <span class="comment">// 对象 iifeObj 执行到声明后便会立即执行 自执行函数，而 fn为自执行函数返回结果</span></span><br></pre></td></tr></table></figure><h2 id="手写-call"><a href="#手写-call" class="headerlink" title="手写 call"></a>手写 <code>call</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.handWritingCall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [callThis,...args] = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">typeof</span> fn === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Not a function'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  callThis.__fn = fn;</span><br><span class="line">  <span class="keyword">const</span> res = callThis.__fn(...args);</span><br><span class="line">  <span class="keyword">delete</span> callThis.__fn;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E8%A1%A8%E8%BE%BE%E5%BC%8F" target="_blank" rel="noopener">JavaScript 表达式定义</a> <span id="Expressions-of-mdn"></span></p><p>[2]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JIT&lt;/strong&gt;&lt;br&gt;—— &lt;code&gt;Just in time&lt;/code&gt; 运行时编</summary>
      
    
    
    
    <category term="notes" scheme="https://blog.scottwu.cn/categories/notes/"/>
    
    
    <category term="爪哇notes" scheme="https://blog.scottwu.cn/tags/%E7%88%AA%E5%93%87notes/"/>
    
  </entry>
  
  <entry>
    <title>es6/generator</title>
    <link href="https://blog.scottwu.cn/2022/06/14/es6-generator/"/>
    <id>https://blog.scottwu.cn/2022/06/14/es6-generator/</id>
    <published>2022-06-14T14:33:55.000Z</published>
    <updated>2022-09-04T05:35:26.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="es6-generator"><a href="#es6-generator" class="headerlink" title="es6-generator"></a><strong>es6-generator</strong></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>  &emsp;&emsp;在各路文档中，了解到 <code>Generator</code> 是一个生成器，目的是为了生成一个 <code>Iterator</code> – <code>&quot;迭代器&quot;</code>，用以进行流程控制，让代码在你需要停止的地方提下来，并能够在下次流程进行的时候在上次停止的地方开始。</p><p>  &emsp;&emsp;其中有几个重要的名次及其概念列举如下：</p><ul><li><p><code>Generator</code> 其译为生成器，目的是为了通过其创建一个迭代器，声明方法如下👇；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>*</code> 的位置并没有强制限制，只要保证在 <code>function</code> 与生成器名称之间就可以了。</p></li><li><p><code>next()</code> 为获取迭代器执行结果的方法，主要用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gf = generatorFun();</span><br><span class="line">gf.next();  <span class="comment">// &#123; value:1, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>  需要注意的是，直接调用 <code>generatorFun</code>，并不能像常规函数那样直接获取函数执行结果，而是获得了一个迭代器 <code>Iterator</code>，在找到的一些文章中，大多愿意称其为指向函数内部状态的 <code>指针对象</code>，当调用迭代器对象内的 <code>next</code> 方法时，其指针便会从函数头部或上一次停下来的地方继续执行；</p></li><li><p><code>yield</code> 其译为产出，产出的是其后面的表达式的运行结果，然后在 <code>yield</code> 处暂停执行，直到下次调用 <code>next</code> 方法触发才会在停止处继续执行，且当 <code>yield</code> 用在表达式中时，需要放在圆括号里，如下，：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="string">'world'</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="string">'world'</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a><strong>基本用法</strong></h2><p>  &emsp;&emsp;从上述描述中基本可以了解到 <code>Generator</code> 的基本用法如下👇图所示。</p><p>  <img src="/images/generator.png" alt="Generator 基本用法流程图"></p><p>  &emsp;&emsp;其中有这么几个需要注意的点<sup><a href="#flowchat-diff">[1]</a></sup>：</p><ul><li><p>如上图中的代码，即使只有一个 <code>yield</code>，当第一次调用 <code>gf.next()</code> 也并没有直接到 <code>done</code> 的状态，这其实比较好理解，因为第一次的 <code>next</code> 并没有使代码运行到函数尾部，而是停留在了 <code>yield</code> 上，尽管 <code>yield</code> 之后再无可执行代码；</p></li><li><p>生成器函数执行流程区别于普通函数，举个🌰：<br><img src="/images/flowchat-diff.png" alt="生成器函数与普通函数比较"><br>从上图可以看到，普通函数与生成器函数的执行顺序主要区别在于 <code>yield</code> 表达式使得每一次调用 <code>next</code> 最终都会将函数暂停在 <code>yield</code> 表达式或者函数尾部，直到下次调用 <code>next</code> 将从上一个 <code>yield</code> 运行到下一个 <code>yield</code> 或者函数尾部。</p></li><li><p>从上图的生成函数代码中会发现一个问题，就是最后的输出结果是 <code>NaN</code>，这其实是因为 <code>yield</code> 只负责<code>“产出”</code>导致的，也就是 <code>yield</code> 表达式并不能将它右侧的表达式运行结果返回到左侧，而如果需要上一步的结果，则可以借助 <code>next</code> 来进行传参，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. a"</span>, a) <span class="comment">// 2</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gf = generatorFun();</span><br><span class="line"><span class="keyword">const</span> a = gf.next();</span><br><span class="line">gf.next(a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a><strong>进阶</strong></h2><h3 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a><strong><code>for of</code></strong></h3><p>  &emsp;&emsp;<code>for of</code> 循环可以自动遍历 <code>Generator</code> 函数时生成的 <code>Iterator</code> 对象，且此时不再需要调用 <code>next</code> 方法。如下：<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">for0f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' javascript'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> for0f())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. ~ v"</span>, v)</span><br><span class="line">&#125; <span class="comment">// 'hello', ' ', 'world'</span></span><br></pre></td></tr></table></figure><br>  &emsp;&emsp;通过观察输出结果，我们发现一个问题，就是最后的 <code>javascript</code> 并没有输出出来，这是因为 <code>for of</code> 循环在 <code>done === true</code> 时便中止掉了，并且不会返回当前结果，所以最后的 <code>return</code> 结果并没有获取到。</p><p>  &emsp;&emsp;除了 <code>for...of</code> 循环以外，扩展运算符（<code>...</code>）、解构赋值和 <code>Array.from</code><sup><a href="#array-from">[2]</a></sup> 方法内部调用的，都是遍历器接口。这意味着，它们都可以将 <code>Generator</code> 函数返回的 <code>Iterator</code> 对象，作为参数。<sup><a href="#es6-generator-jianshu1">[3]</a></sup></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">for0f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">' '</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'javascript'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> for0f()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'hello', ' ', 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...for0f()] <span class="comment">// ['hello', ' ', 'world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z] = for0f();</span><br><span class="line">x <span class="comment">// 'hello'</span></span><br><span class="line">y <span class="comment">// ' '</span></span><br><span class="line">z <span class="comment">// 'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(for0f()) <span class="comment">// ['hello', ' ', 'world]</span></span><br></pre></td></tr></table></figure><h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a><strong><code>Generator.prototype.throw()</code></strong></h3><p>  &emsp;&emsp;一个在生成器函数外部向函数体内部抛出错误的方法。</p><h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a><strong><code>Generator.prototype.return()</code></strong></h3><p>  &emsp;&emsp;一个在生成器函数外部向函数体内部 <code>return</code>，并终结遍历。</p><h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a><strong><code>yield*</code></strong></h3><p>  &emsp;&emsp;<code>yield*</code> 表达式用于委托给另一个 <code>generator</code> 或 <code>可迭代对象</code><sup><a href="#iterable-object">[4]</a></sup>。<sup><a href="#es6-yield*">[5]</a></sup></p><p>  &emsp;&emsp;<code>yield*</code> 有区别于 <code>yield</code>。<code>yield</code> 可以将其理解为暂停标识符，即在 <code>yield</code> 处开始或停止。而 <code>yield*</code> 则可以理解为展开一个可迭代对象进行迭代。举个🌰：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* gf2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>  &emsp;&emsp;上述代码其实可以看作等价于下面的代码<br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  yield_return <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  &emsp;&emsp;只不过有一条需要注意的是 <code>yield_return</code> 是我为了方便理解自己定义的一个标识，实际上是没有这个东西的。之所以这么定义是因为 <code>yield*</code> 所委托的迭代对象 <code>return</code> 的 <code>value</code> 将作为返回值返回到 <code>yield*</code> 表达式上，再举个🌰：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> v = <span class="keyword">yield</span>* gf2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"🐛. ~ function*gf1 ~ v"</span>, v)  <span class="comment">// 🐛. ~ function*gf1 ~ v,3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gf2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> iterable1 = gf1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  iterable1.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://blog.csdn.net/weixin_39798049/article/details/87111633" target="_blank" rel="noopener">es 异步流程(二)之generator篇</a> <span id="flowchat-diff"></span></p><p>[2]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from</a> <span id="array-from"></span></p><p>[3]. <a href="https://www.jianshu.com/p/56000dcf7cfe" target="_blank" rel="noopener">ES6中的Generator函数</a> <span id="es6-generator-jianshu1"></span></p><p>[4]. <a href="https://juejin.cn/post/6873457657018728456" target="_blank" rel="noopener">JS 可迭代对象</a> <span id="iterable-object"></span></p><p>[5]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*" target="_blank" rel="noopener">yield*</a> <span id="es6-yield*"></span></p><p>[6]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;es6-generator&quot;&gt;&lt;a href=&quot;#es6-generator&quot; class=&quot;headerlink&quot; title=&quot;es6-generator&quot;&gt;&lt;/a&gt;&lt;strong&gt;es6-generator&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;</summary>
      
    
    
    
    
    <category term="ECMAScript" scheme="https://blog.scottwu.cn/tags/ECMAScript/"/>
    
  </entry>
  
  <entry>
    <title>http/cookies</title>
    <link href="https://blog.scottwu.cn/2022/06/07/http-cookies/"/>
    <id>https://blog.scottwu.cn/2022/06/07/http-cookies/</id>
    <published>2022-06-07T12:55:30.000Z</published>
    <updated>2022-08-14T06:01:53.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="About-Cookies"><a href="#About-Cookies" class="headerlink" title="About Cookies"></a>About Cookies</h1><h2 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. <code>Cookie</code></h2><p>  &emsp;&emsp;一般来讲，由服务端创建并存储携带在 <code>http Response Headers</code> 的 <code>Set-Cookie</code> 中，并在浏览器下次请求同一服务器时，通过 <code>Request Headers</code> 的 <code>Cookie</code> 字段发送给后端。<br><br>  <code>Cookie</code> 是无状态http的<em>状态</em>。</p><p>  <img src="/images/cookies-circle.png" alt="cookie 流转图"></p><p>  <code>Cookie</code> 目前主流用法：</p><ul><li><p>会话状态管理；</p></li><li><p>个性化设置/推荐（广告投放）；</p></li><li><p>浏览器行为跟踪；</p><p>&emsp;&emsp;同时，不仅仅是只有服务端才可创建 <code>Cookie</code>，浏览器或者说客户端也可操作 <code>Cookie</code>，如：<code>document.cookie</code>。<span id="cookies-create-javascript"></span></p></li></ul><h2 id="2-Cookie-生命周期"><a href="#2-Cookie-生命周期" class="headerlink" title="2. Cookie 生命周期"></a>2. <code>Cookie</code> 生命周期</h2><p>  &emsp;&emsp;<code>Cookie</code> 的生命周期可以通过 <code>Expires</code> 或 <code>Max-Age</code> 来定义。</p><p>  &emsp;&emsp;有趣的是，经过我的测试发现无论是在前端（浏览器）上直接设置 <code>Expires/Max-Age</code> 还是经过 <code>Node</code> 服务器进行设置 <code>Expires/Max-Age</code> 其最终都会被计算成日期传到前端。</p><p>  &emsp;&emsp;也就是说，在前端可以看到或者说获取到的 <code>Cookie</code> 值其实只有两种，分别是 <code>Date()</code> 类型和 <code>Session</code> 。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">🥇 Date() 日期类型</span><br><span class="line">🥈 Session &#x2F;&#x2F; 仅在当前会话有效</span><br></pre></td></tr></table></figure><p>  &emsp;&emsp;关于 <code>Cookie</code> 过期验证，没什么好验证的，过期的 <code>Cookie</code> 就直接被浏览器删掉了，根本到不了后端。就算你手动添加一个，那也不是之前那个了，因为那就相当于又重新生效了一个同名 <code>Cookie</code> 而已。</p><h2 id="3-限制访问-Cookie"><a href="#3-限制访问-Cookie" class="headerlink" title="3. 限制访问 Cookie"></a>3. 限制访问 <code>Cookie</code></h2><p>  &emsp;&emsp;有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和 <code>HttpOnly</code> 属性<sup><a href="#cookies-of-mdn">[1]</a></sup>。</p><ul><li><code>Secure</code> 只能用在https协议上传输；</li><li><code>HttpOnly</code> 客户端通过 <code>document.cookie</code> 无法获取设置该属性的 <code>Cookie</code> 字段；</li></ul><h2 id="4-Cookie-作用域"><a href="#4-Cookie-作用域" class="headerlink" title="4. Cookie 作用域 "></a>4. <code>Cookie</code> 作用域 <span id="cookies-scope"></span></h2><p>  &emsp;&emsp;<code>Domain</code> 和 <code>Path</code> 标识定义了 <code>Cookie</code> 的作用域：即允许 <code>Cookie</code> 应该发送给哪些URL<sup><a href="#cookies-of-mdn">[1]</a></sup>。</p><ul><li><p><code>Domain</code>：<code>Cookie</code> 作用的域名，指定 <code>Domain</code> 时，作用的域名为指定域名及其子域名，若未指定，则默认为当前 <code>origin</code> 且不包含子域名；</p></li><li><p><code>Path</code>：总结为两句话。若设置了，则已设置的值为准，若未设置，则由 <code>URL</code> 的 <code>path</code> 的最后一个 <code>/</code> 向前截取，截取的结果作为 <code>Cookie</code> 的 <code>Path</code>。其作用域为当前 <code>path</code> 路径下的所有子路径，包含当前路径<sup><a href="#cookie-path-rules">[2]</a></sup>；</p></li></ul><h2 id="5-SameSite-属性"><a href="#5-SameSite-属性" class="headerlink" title="5. SameSite 属性"></a>5. <code>SameSite</code> 属性</h2><p>  &emsp;&emsp;<code>SameSite</code> 顾名思义——同一站点的配置项，理解来讲就是来限制 <code>Cookie</code> 传播是否受”同一站点—— <code>SameSite</code> “的限制。</p><p>  &emsp;&emsp;<code>MDN</code> 里这样描述：<code>SameSite Cookie</code> 允许服务器要求某个 <code>cookie</code> 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（<code>CSRF</code>）<sup><a href="#cookies-of-mdn">[1]</a></sup>。</p><p>  <code>SameSite</code> 共有下面三种值<sup><a href="#cookie-samesite-attrs">[3]</a></sup><sup><a href="#what-is-cookie-samesite">[4]</a></sup>：</p><ul><li><p><code>None</code>：就是没有限制，<code>Cookie</code> 想怎么传就怎么传；</p></li><li><p><code>Strict</code>：<code>Strict</code>（严格）模式，严格到只有当前 <code>top.window</code> 对象的 <code>url</code> 及其子 <code>url</code> 才有资格传播，但不代表一定会传播，因为还要满足 <a href="#cookies-scope"><code>Cookie</code> 作用域</a> 的限制；</p></li><li><p><code>Lax</code>：<code>Lax</code>（不严格）模式，即存在一些情况可以传播 <code>Cookie</code>；</p><p>具体情况见下图描述⬇️。<sup><a href="#cookie-samesite-conf">[5]</a></sup></p><p><img src="https://upload-images.jianshu.io/upload_images/19506176-0f3e256e10049c7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1102/format/webp" alt="SameSite"></p></li></ul><h2 id="6-Cookie-prefixes"><a href="#6-Cookie-prefixes" class="headerlink" title="6. Cookie prefixes"></a>6. <code>Cookie prefixes</code></h2><p>  &emsp;&emsp;<code>Cookie prefixes</code> 指在 <code>Cookie</code> 名前添加绑定的前缀：<code>&quot;__Host-&quot;</code> 与 <code>&quot;__Secure-&quot;</code>。</p><ul><li><code>__Host-</code>：<code>MDN</code> 这么解释道：它需要设置 <code>Secure</code> 属性，并且来自安全的 <code>origin</code>，同时还要设置 <code>Path</code> 为 <code>/</code>，但 <code>Domain</code> 要为默认值，即只有在当前安全的 <code>host</code> 下才可传播发送该 <code>Cookie</code>, 同时 <code>MDN</code> 称之为 <code>domain-locked</code>, 我理解其为<code>&quot;被锁定的域&quot;</code>。</li><li><code>__Secure-</code>：相较于 <code>__Host-</code>，其仅要求来自安全的 <code>origin</code>，并设置 <code>Secure</code> 属性才可传播发送。</li></ul><h2 id="7-JavaScript-通过-Document-cookie-访问-Cookie"><a href="#7-JavaScript-通过-Document-cookie-访问-Cookie" class="headerlink" title="7. JavaScript 通过 Document.cookie 访问 Cookie"></a>7. <code>JavaScript</code> 通过 <code>Document.cookie</code> 访问 <code>Cookie</code></h2><p>  &emsp;&emsp;在<a href="#cookies-create-javascript">第一章节</a>中就已经剪短提到过通过 <code>JavaScript</code> 对 <code>Cookie</code> 进行操作的方法，但该方法仅可访问创建非 <code>HttpOnly</code> 标记的 <code>Cookie</code>。</p><h2 id="8-Cookie-安全"><a href="#8-Cookie-安全" class="headerlink" title="8. Cookie 安全"></a>8. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8" target="_blank" rel="noopener"><code>Cookie</code> 安全</a></h2><p>  &emsp;&emsp;凡事涉及安全的问题都不会是小问题。</p><p>  &emsp;&emsp;这里不太好概述，理解的也不深，直接贴链接吧</p><hr><blockquote><p>参考资料:</p><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">HTTP cookies of MDN</a> <span id="cookies-of-mdn"></span></p><p>[2]. <a href="https://www.jianshu.com/p/48556e5c44f5" target="_blank" rel="noopener">Cookie的path值的默认规则</a> <span id="cookie-path-rules"></span></p><p>[3]. <a href="https://www.youtube.com/watch?v=aUF2QCEudPo" target="_blank" rel="noopener">Cookie SameSite</a> <span id="cookie-samesite-attrs"></span></p><p>[4]. <a href="https://www.leixue.com/ask/what-is-samesite" target="_blank" rel="noopener">SameSite 是什么</a> <span id="what-is-cookie-samesite"></span></p><p>[5]. <a href="https://www.jianshu.com/p/dd73c27ab8d6" target="_blank" rel="noopener">Cookie中的SameSite设置</a> <span id="cookie-samesite-conf"></span></p><p>[6]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">Cookie 安全 of MDN</a> <span id="cookie-security-of-mdn"></span></p><p>[7]. <a href="http://www.markdown.cn/" target="_blank" rel="noopener">Markdown syntax</a></p></blockquote><hr><h6 id="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。"><a href="#以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人-✉️-邮箱。" class="headerlink" title="以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 ✉️ 邮箱。"></a>以上描述及解决方案均属个人观点，若您存在任何疑问及意见，还请联系本人 <a href="mailto:wyx.scottwu@gmail.com">✉️ 邮箱</a>。</h6>]]></content>
    
    
    <summary type="html">http-cookies 学习记录，顺序参考 MDN</summary>
    
    
    
    
    <category term="HTTP" scheme="https://blog.scottwu.cn/tags/HTTP/"/>
    
  </entry>
  
</feed>
